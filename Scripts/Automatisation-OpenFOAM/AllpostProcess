#!/bin/bash

. ${WM_PROJECT_DIR:?}/bin/tools/RunFunctions  #Charger les scripts OpenFOAM

usage() {
    echo "Utilisation : AllpostProcess [OPTIONS] <script1> <script2> ... <scriptN>"
    echo "  --log=<log_file> : définir un autre fichier log dans"
    echo "      lequel lire."
    echo "  -h, --help : afficher l'aide complète"
}

send_help() {
    echo
    echo "Utilisation : AllpostProcess [OPTIONS] <script1> <script2> ... <scriptN>"
    echo
    echo "Lance une série de scripts lorsque la simulation est terminée. La"
    echo "fin de la simulation est basée sur le fichier log de sortie de "
    echo "simulation, au format log.nomSolver, où nomSolver est le nom du "
    echo "solveur donné dans controlDict. Il est possible de changer le nom"
    echo "du fichier avec l'option --log=<fichier_log>."
    echo
    echo "OPTIONS"
    echo "-------"
    echo "   --log=<log_file> : définir un autre fichier log dans"
    echo "      lequel lire."
    echo "   -h, --help: Afficher l'aide"
    echo
    echo "ERREURS"
    echo "-------"
    echo "   1 en cas de problème de lecture d'option"
    echo "   2 en cas de problème de lecture de fichier"
    echo

}

# Vérifier le code de sortie de $?. Si différent de 0, renvoie le code d'erreur $2
# Donner le nom de l'application dans $1
check_exit_code() {
	if [ ! $? -eq 0 ]; then
		echo "--> Erreur : ${1} a échoué."
		exit ${2}
	else
		echo "${1} terminé"
	fi
}

execute_scripts() {
    #Pour chaque paramètre, l'exécuter
    for script in $@ ; do
        echo "Execution de ${script}"
        $script
        check_exit_code "${script}" 2
    done
}

#==============================================================================

LOGFILE="log.$(getApplication)" #Définir fichier log

# * * * * * * * * * * * * * Lecture des arguments * * * * * * * * * * * * * * *

#Lire les arguments et options avec getopt
#Explication : 
#     -n Allpostprocess : permet que le message d'erreur soit "Allrun ..." et pas
#			"getopt ..."
#	  -o h : lecture d'options courtes de type -h
#	  -l log,... : lecture d'options longues de type --log, etc
#     -- : signale la fin des options
PARSED_ARGS=$(getopt -n Allpostprocess -o h: -l log:,help -- "$@")

#Vérifier que tout s'est bien passé
if [ ! "${?}" -eq 0 ] ; then
	usage
	exit 1
fi

#Ranger les options lues par getopt dans $1, $2, etc
eval set -- "${PARSED_ARGS}"

# On parcourt les paramètres donnés par l'utilisateur
for key in $@ ; do 

	case $key in
		-h|--help)     # Afficher l'aide et quitter
		    send_help
		    exit 0
		    ;;
        --log)      # Précise le fichier logfile
            shift  #Le paramètre suivant est le nom du fichier log
            LOGFILE=${1}
            echo "Fichier log défini à : ${LOGFILE}"
            ;;
        --)        # Fin des paramètres
            shift
            break
            ;;
		*)   # Autre option 
            #Si le paramètre donné commence par un tiret, il n'est pas accepté
            if [ ! -z $(echo $key | grep -o "\-") ]; then
                echo
                echo "Erreur : argument invalide ${key}"
                usage
                exit 1
            fi
		;;
	esac
	
done 

#Vérifier si il y a bien une liste d'arguments
if [ $# -eq 0 ]; then
    echo "Erreur : aucun script donné en paramètre"
    usage
    exit 1
fi

#==============================================================================

#Lire le dernier temps de simulation
TIME=$(tail -100 ${LOGFILE} | grep ^Time | tail -1 | grep -o "[0-9].*")
check_exit_code "Lecture du fichier ${LOGFILE}" 2
echo "Dernier temps dans le fichier ${LOGFILE} : ${TIME}"

EMPTY_IF_END=$(tail ${LOGFILE} | grep "^End")

#Boucler tant qu'on a pas terminé 
while [ -z $EMPTY_IF_END ] && [ ! -z "${TIME}" ] ; do

    echo "Réexecution automatique dans 60 secondes"
    sleep 60

    #Lire le dernier temps de simulation
    TIME=$(tail -100 ${LOGFILE} | grep ^Time | tail -1 | grep -o "[0-9].*") 
    echo "Dernier temps dans le fichier ${LOGFILE}: ${TIME}"

    EMPTY_IF_END=$(tail ${LOGFILE} | grep "^End")

done

echo "Simulation terminée"
execute_scripts $@

echo
echo "Terminé"