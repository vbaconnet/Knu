#!/bin/bash

# !! Important !!
# Pour une documentation de ce script, se référer aux fonctions send_help()
# et usage() ci-dessous

. ${WM_PROJECT_DIR:?}/bin/tools/RunFunctions  #Charger les scripts OpenFOAM

#Utilisation du script
usage() {
	echo "Utilisation : Allrun [OPTIONS]"
	echo
	echo "  -c, --clean : Nettoyer le répertoire (maillage, dossiers de résult"
    echo "     -ats, dossiers de processeurs, fichiers log)"
	echo "  -s, --setfields : Lancer setFields selon les critères de "
	echo "      setFieldsDict"
	echo "  -t, --toposet : Lancer topoSet selon les critères de topoSetDict"
	echo "  -p, --parallel : Lancer le calcul en parallèle avec le nombre de pro"
    echo "     -cesseurs défini dans decomposeParDict"
	echo "  -r, --noreconstruct : pour ne pas reconstruire les fichiers après "
	echo "      le calcul parallèle"
    echo "  -h, --help : afficher l'aide"
}

#Aide
send_help() {
	echo "Utilisation : Allrun [OPTIONS]"
	echo
    echo "Lance le calcul OpenFOAM selon le solveur défini dans controlDict"
    echo "Peut lancer le calcul en parallèle selon les critères définis dans"
    echo "decomposeParDict. Le solveur est lancé en arrière-plan."
	echo 
	echo "OPTIONS"
	echo "-------"
	echo "  -c, --clean : Nettoyer le répertoire (maillage, dossiers de résult"
    echo "     -ats, dossiers de processeurs, fichiers log)"
	echo "  -s, --setfields : Lancer setFields selon les critères de "
	echo "      setFieldsDict"
	echo "  -t, --toposet : Lancer topoSet selon les critères de topoSetDict"
	echo "  -p, --parallel : Lancer le calcul en parallèle avec le nombre de pro"
    echo "     -cesseurs défini dans decomposeParDict"
	echo "  -r, --noreconstruct : pour ne pas reconstruire les fichiers après "
	echo "      le calcul parallèle"
    echo "  -h, --help : afficher l'aide"
	echo
	echo "ERREURS"
	echo "-------"
	echo "  1 pour argument ou option invalide"
	echo "  4 si erreur dans decomposePar"
	echo "  7 si erreur de lancement du solveur"
    echo "  8 si erreur dans reconstructPar "
	echo "  9 si erreur dans la copie du dossier 0"
	echo "  10 si erreur dans setFields"
}

#Nettoyer le répertoire 
clean() {

    echo "Nettoyage du répertoire $(pwd)"

	# Si Allclean existe, l'utiliser
	if [ -f "Allclean" ]; then 
		./Allclean
	
	# Sinon faire ça manuellement
	else 					   
		# Remove the mesh
		foamCleanPolyMesh

		# Remove time folders
		foamListTimes -rm -time 0: -withZero

		# Remove processor directories
		rm -rf  processor*

		# Remove logs
		rm  -f log.*
	fi
}

# Vérifier le code de sortie de $?. Si différent de 0, renvoie le code d'erreur $2
# Donner le nom de l'application dans $1
check_exit_code() {
	if [ ! $? -eq 0 ]; then
		echo "--> Erreur : ${1} a échoué. Consulter log.${1} pour plus de détails"
		exit ${2}
	else
		echo "${1} terminé"
	fi
}

#Variables pour la lecture des options
#-------------------------------
PARALLEL=false
DIR_WAS_CLEANED=false
RECONSTRUCT=true
SETFIELDS=false
TOPOSET=false
#-------------------------------

#Lire les arguments et options avec getopt
#Explication : 
#     -n Allrun : permet que le message d'erreur soit "Allrun ..." et pas
#			"getopt ..."
#	  -o cstprh : lecture d'options courtes de type -h, -s... etc ou -hs
#	  -l clean,... : lecture d'options longues de type --clean, etc
#     -- : signale la fin des options
PARSED_ARGS=$(getopt -n Allrun -o cstprh -l clean,setfields,toposet,parallel,noreconstruct,help -- "$@")

#Vérifier que tout s'est bien passé
if [ ! "${?}" -eq 0 ] ; then
	usage
	exit 1
fi

#Ranger les options lues par getopt dans $1, $2, etc
eval set -- "${PARSED_ARGS}"

# On parcourt les paramètres donnés par l'utilisateur
while [ ! "${#}" -eq 0 ] ; do

	case "${1}" in
		-h|--help)            # Afficher l'aide et quitter
		send_help
		exit 0
		;;
		-p|--parallel)        # activer le calcul parallèle
		PARALLEL=true
		shift
		;;
		-c|--clean)           # nettoyer le dossier
		clean
		DIR_WAS_CLEANED=true
		shift
		;;
		-r|--noreconstruct)   # Ne pas reconstruire après calcul parallèle
		RECONSTRUCT=false
		shift
		;;
		-s|--setfields)       # Lancer setFields
		SETFIELDS=true
		shift
		;;
		-t|--toposet)         # Lancer topoSet
		TOPOSET=true
		shift
		;;
		--)                   # Fin des arguments
		shift
		break
		;;
		*)                    # Autre option invalide
		echo
		echo "Allmesh : ${1} : argument invalide "
		usage
		exit 1
		;;
	esac
	
done 

if ! $PARALLEL && ! $RECONSTRUCT ; then
	echo
	echo "--> Warning : option -r activée sans calcul parallèle"
	echo "  ** Conseil ** Utilisez l'option -p pour activer le calcul parallèle"
fi

#Copie du dossier 0
if [ -d "0" ] ; then
	echo "Le dossier 0 existe déjà. Aucune action effectuée"
else
	echo "Dossier 0 non trouvé. Recherche de 0.orig..."
	ZERODIR=""

	#Recherche de 0.orig
	if [ -d "0.orig" ] ; then 
		echo "0.orig trouvé" 
		ZERODIR="0.orig" 

	else 
		echo "0.orig pas trouvé. Recherche de 0_orig..."

		#Si pas trouvé, recherche de 0_orig
		if [ -d "0_orig" ] ; then
			echo "0_orig trouvé" 
			ZERODIR="0_orig"
		else 
			echo "0_orig pas trouvé. Recherche de 0_org..."

			#Si pas trouvé, recherche de 0_org
			if [ -d "0_org" ] ; then 
				echo "0_org trouvé"
				ZERODIR="0_org"
			else
				#Si pas trouvé, renvoyer une erreur
				echo "0_org pas trouvé."
				echo 
				echo "--> Erreur : aucun dossier 0, 0.orig, 0_orig ou 0_org trouvé"
				exit 9
			fi
		fi
	fi

cp -r "${ZERODIR}" 0  # Copie du dossier 0_org ou 0_orig vers 0
echo "Dossier 0 créé"
fi

#Lancement de setFields
if $SETFIELDS ; then
	runApplication setFields
	check_exit_code "setFields" 10
fi

#Lancement en parallèle
if $PARALLEL ; then    

	#Lancer decomposePar
    runApplication decomposePar
    check_exit_code "decomposePar" 4
	rm -f log.decomposePar

	#Lancer le solveur donné dans system/controlDict
    runParallel $(getApplication)
    check_exit_code "$(getApplication)" 7

	#Reconstruction des fichiers et effaçage des dossiers si succès 
	if $RECONSTRUCT ; then
		runApplication reconstructPar 
		check_exit_code "reconstructPar" 8
		rm -rf processor*
	fi

#Lancement en séquentiel
else
    runApplication $(getApplication) 
    check_exit_code "$(getApplication)" 7
fi

echo "Terminé."